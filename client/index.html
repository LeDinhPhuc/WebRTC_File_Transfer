<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="./public/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WebRTC File Transfer</title>
  </head>

  <body>
    <form id="fileInfo">
      <input type="file" id="fileInput" name="files" />
    </form>
    <ul id="files">
      <a id="download"></a>
    </ul>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.1/socket.io.js"></script>

    <script>
      function getParameterByName(name, url) {
        if (!url) url = window.location.href;
        switch (name) {
          case "room":
            return url;
          default:
            return url;
        }
      }

      const fileInput = document.querySelector("input#fileInput");
      const downloadAnchor = document.querySelector("a#download");

      // this function use to get url parameters
      let room = getParameterByName("room");
      let userID = getParameterByName("userid");
      let name = getParameterByName("name");
      let peer_connection = null;

      /** CONFIG **/
      const SIGNALING_SERVER = "http://localhost:5000/"; //your  node server addres  or  IP adress
      const ICE_SERVERS = [{ urls: "stun:stun.l.google.com:19302" }];

      let socket = null;
      /* our socket.io connection to our webserver */
      let peers = {};
      /* keep track of our peer connections, indexed by peer_id (aka socket.io id) */
      let peer_media_elements = {};
      /* keep track of our <video>/<audio> tags, indexed by peer_id */
      $(document).ready(function (a) {
        socket = io.connect(SIGNALING_SERVER);
        //----------------------------------------------------------------------->>>>> Files Send Start
        const BYTES_PER_CHUNK = 1024;
        let file;
        let currentChunk;
        let fileInput = $("input[type=file]");
        let fileReader = new FileReader();

        function readNextChunk() {
          let start = BYTES_PER_CHUNK * currentChunk;
          let end = Math.min(file.size, start + BYTES_PER_CHUNK);
          fileReader.readAsArrayBuffer(file.slice(start, end));
        }

        fileReader.onload = function () {
          socket.emit("file-send-room-result", fileReader.result);
          // create cadidate and use Datachannel to send file
          currentChunk++;
          if (BYTES_PER_CHUNK * currentChunk < file.size) {
            readNextChunk();
          }
        };

        fileInput.on("change", function () {
          file = fileInput[0].files[0];
          currentChunk = 0;
          // send some metadata about our file
          // to the receiver
          socket.emit(
            "file-send-room",
            JSON.stringify({
              fileName: file.name,
              fileSize: file.size,
            })
          );
          readNextChunk();
        });

        let incomingFileInfo;
        let incomingFileData;
        let bytesReceived;
        let downloadInProgress = false;

        socket.on("file-out-room", function (data) {
          console.log("start download data ", data);
          startDownload(data);
        });

        socket.on("file-out-room-result", function (data) {
          console.log("progressDownload ", data);
          progressDownload(data);
        });

        function startDownload(data) {
          incomingFileInfo = JSON.parse(data.toString());
          incomingFileData = [];
          bytesReceived = 0;
          downloadInProgress = true;
          console.log(
            "incoming file <b>" +
              incomingFileInfo.fileName +
              "</b> of " +
              incomingFileInfo.fileSize +
              " bytes"
          );
        }

        function progressDownload(data) {
          bytesReceived += data.byteLength;
          incomingFileData.push(data);
          console.log(
            "progress: " +
              ((bytesReceived / incomingFileInfo.fileSize) * 100).toFixed(2) +
              "%"
          );
          if (bytesReceived === incomingFileInfo.fileSize) {
            endDownload();
          }
        }

        function endDownload() {
          downloadInProgress = false;
          let blob = new Blob(incomingFileData);
          let a = document.createElement("a");
          const files = document.getElementById("files");
          files.appendChild(a);
          a.style = "display: block";
          let url = window.URL.createObjectURL(blob);
          a.href = url;
          a.download = incomingFileInfo.fileName;
          a.innerHTML = incomingFileInfo.fileName;
          // a.click();
          window.URL.revokeObjectURL(url);
        }

        //==================================================================<<< Filse Send End

        function join_chat_channel(channel, userdata) {
          socket.emit("join-room", { channel: channel, userdata: userdata });
        }

        socket.on("connect", function (userID) {
          console.log("Connected to signaling server");
          name = socket.id;
          userID = socket.id;
          join_chat_channel(room, { name: name, userID: userID });
        });

        socket.on("room-user", function (data) {
          console.log(data);
          $("#online-user").append(
            "<tr><td>Name = " +
              data.userdata.name +
              " <br> User ID= " +
              data.userdata.userID +
              '</td><td><button class="call" id="' +
              data.userdata.userID +
              '">Call</button></td></tr>'
          );
        });
        socket.on("addPeer-room", function (config) {
          console.log("Signaling server said to add peer:", config);
          const { peer_id } = config;
          if (peer_id in peers) {
            console.log("Already connected to peer ", peer_id);
          }

          peer_connection = new RTCPeerConnection(
            { iceServers: ICE_SERVERS },
            { optional: [{ DtlsSrtpKeyAgreement: true }] }
            // Chrome and Firefox to interoperate.
          );

          peers[peer_id] = peer_connection;

          peer_connection.onicecandidate = function (event) {
            console.log("event cadidate :", event.candidate);
            if (event.candidate == null) {
              return;
            }

            socket.emit("relayICECandidate-room", {
              peer_id,
              ice_candidate: {
                sdpMLineIndex: event.candidate.sdpMLineIndex,
                candidate: event.candidate.candidate,
              },
            });
          };
        });
        /**
         * Peers exchange session descriptions which contains information
         * about their audio / video settings and that sort of stuff. First
         * the 'offerer' sends a description to the 'answerer' (with type
         * "offer"), then the answerer sends one back (with type "answer").
         */
        socket.on("sessionDescription-room", function (config) {
          console.log("Remote description received: ", config);
          let { peer_id } = config;
          let peer = peers[peer_id];
          let { remote_description, session_description } = config;
          console.log({ session_description });

          let desc = new RTCSessionDescription(remote_description);
          let stuff = peer.setRemoteDescription(
            desc,
            function () {
              console.log("setRemoteDescription succeeded");

              if (remote_description.type == "offer") {
                console.log("Creating answer");
                peer.createAnswer(
                  function (local_description) {
                    console.log("Answer description is: ", local_description);
                    peer.setLocalDescription(
                      local_description,
                      function () {
                        socket.emit("relaySessionDescription-room", {
                          peer_id: peer_id,
                          session_description: local_description,
                        });
                        console.log("Answer setLocalDescription succeeded");
                      },
                      function () {
                        Alert("Answer setLocalDescription failed!");
                      }
                    );
                  },
                  function (error) {
                    console.log("Error creating answer: ", error);
                    console.log({ peer });
                  }
                );
              }
            },
            function (error) {
              console.log("setRemoteDescription error: ", error);
            }
          );
          console.log("Description Object: ", desc);
        });
        /**
         * The offerer will send a number of ICE Candidate blobs to the answerer so they
         * can begin trying to find the best path to one another on the net.
         */
        socket.on("iceCandidate-room", function (config) {
          let peer = peers[config.peer_id];
          let ice_candidate = config.ice_candidate;
          peer.addIceCandidate(new RTCIceCandidate(ice_candidate));
        });
        /**
         * When a user leaves a channel (or is disconnected from the
         * signaling server) everyone will recieve a 'removePeer' message
         * telling them to trash the media channels they have open for those
         * that peer. If it was this client that left a channel, they'll also
         * receive the removePeers. If this client was disconnected, they
         * wont receive removePeers, but rather the
         * signaling_socket.on('disconnect') code will kick in and tear down
         * all the peer sessions.
         */
        socket.on("removePeer-room", function (config) {
          console.log("Signaling server said to remove peer:", config);
          let peer_id = config.peer_id;
          if (peer_id in peer_media_elements) {
            peer_media_elements[peer_id].remove();
          }
          if (peer_id in peers) {
            peers[peer_id].close();
          }
          delete peers[peer_id];
          delete peer_media_elements[config.peer_id];
        });
      });
    </script>
  </body>
</html>
